using System.Collections.Generic;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace TheHunt.MediaR.SourceGen;

[Generator]
public class RpcMediatorIncrementalGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // https://andrewlock.net/exploring-dotnet-6-part-9-source-generator-updates-incremental-generators/
        // https://github.com/davidwengier/SourceGeneratorTemplate/blob/main/SourceGenerator/IncrementalGenerator.cs

        var classDeclarations = context.SyntaxProvider.CreateSyntaxProvider(
            predicate: static (node, _) => node is AliasQualifiedNameSyntax { Alias.Identifier.Text: "grpc", Name.Identifier.Text: "BindServiceMethod" },
            transform: static (context, _) => GetSemanticTarget(context)).Where(c => c is not null);

        context.RegisterSourceOutput(classDeclarations, Execute!);
    }

    private static void Execute(SourceProductionContext context, ClassDeclarationSyntax rpcService)
    {
        var set = new HashSet<(string Namespace, string Request, string Result)>();
        foreach (var member in rpcService.Members)
        {
            if (member is not MethodDeclarationSyntax method)
                continue;

            var requestType = (QualifiedNameSyntax)method.ParameterList.Parameters[0].Type!;
            var requestNamespace = requestType.Left.ToString().Substring(8);
            var requestClassType = requestType.Right.ToString();

            var resultType = ((GenericNameSyntax)((QualifiedNameSyntax)method.ReturnType).Right).TypeArgumentList.Arguments[0].ToString();

            set.Add((requestNamespace, requestClassType, resultType));
        }

        foreach (var (@namespace, requestClass, resultType) in set)
        {
            var source = @$"// <auto-generated />
namespace {@namespace}
{{
    public partial class {requestClass} : MediatR.IRequest<{resultType}> {{ }}
}}";
            context.AddSource($"{$"{@namespace}.{requestClass}".Replace('.', '_')}.g.cs", source);
        }
    }

    private static ClassDeclarationSyntax? GetSemanticTarget(GeneratorSyntaxContext context)
    {
        var syntaxNode = (AliasQualifiedNameSyntax)context.Node;

        var parent = syntaxNode.Parent;
        while (parent is not ClassDeclarationSyntax and not null)
        {
            parent = parent.Parent;
        }

        return parent as ClassDeclarationSyntax;
    }
}